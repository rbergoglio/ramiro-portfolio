---
title: "The squared sum problem"
description: "How I solved a math problem with Python and learned about graph theory."
date: "2025-12-29"
tags: ["Python","Math"]
img: "/images/pathselected.png"
---

# The squared sum problem

I bought a book called "Things to Make and Do in the Fourth Dimension" and on one of the first chapters
one of the things Matt Parker talked about was the squared sum problem. It's a math problem that goes like this:

Arrange the numbers 1 to 16 so that the sum of any two adjacent numbers is a perfect square.

So for example: 
```
3 1 8 
```
Is a valid sequence because 3+1=4 and 1+8=9, both perfect squares.

It's something that can be solved with pen and paper, but I am a programmer, so I decided to solve it with Python. In this blog post I'll talk about how I resolved it.

## First steps

I actually started first with pen and paper. My first thought was that the highest numbers would have the least amount of possible adjacents so I started with them.

```
10 15 1 ...

10 15 1 3 ...

10 15 1 8 ...
```

I tried a few combinations but I quickly realized that this was going to be tedious. And what I was doing was similar to backtracking, so I decided to write a program to do it for me.
I know it might not be the best solution, but my goal was to find one solution first without AI or help and then optimize it later or find a better one.

## Backtracking

So what I was doing with pen and paper was basically backtracking. In backtracking, the algorithm tries something and if it fails it goes back to the previous step and tries something else.
It's a brute force approach.

A basic backtracking algorithm has this shape:

```python
options = ["option1","option2","option3"]
solution = []
def backtrack(solution):
    if is_solution(solution):
        return solution
    for option in options:
        if is_valid(option, solution):
            solution.add(option)
            result = backtrack(solution)
            if result is not None:
                return result
            solution.remove(option)
    return None
```

What that says is:
1. If the current solution is valid, return it.
2. If not, let's try all the options. For each option I'll check if there's a valid solution.
3. If I find one solution, for example two adjacents numbers that sum a perfect square, then I keep trying with that solution and remove the numbers.
4. If I don't find a valid solution then I'll stop there and backtrack to a valid solution to continue with the rest of possible solutions.


## The code


```python

import math
    
def is_squared_list(list_of_numbers: list[int]) -> bool:
    for index in range(len(list_of_numbers) - 1):
        # If the root of the sums of each pair of adjacent numbers is an integer (remainder 0)
        # then it's a squared list
        if(math.sqrt(list_of_numbers[index] + list_of_numbers[index+1]) % 1 != 0):
            return False
    return True


def findSquaredList(squaredList: list[int], sixteenNumbers: list[int]) -> list[int] | None:
    if len(sixteenNumbers) == 0:
        return squaredList if is_squared_list(squaredList) else None
    else:
        for index, item in enumerate(sixteenNumbers):
            newlist= squaredList + [item]
            if(is_squared_list(newlist)):
                newSixteenNumbers = sixteenNumbers[:index] + sixteenNumbers[index+1:]
                result = findSquaredList(newlist, newSixteenNumbers)
                if result is not None:
                    return result
        return None

sixteenNumbers = [i for i in range(1,17)]
print(findSquaredList([],sixteenNumbers))

```

And Ta daaaa I got the only possible solution (except it's reverse):

```
[8, 1, 15, 10, 6, 3, 13, 12, 4, 5, 11, 14, 2, 7, 9, 16]
```

Backtracking is known to have a really bad algorithm complexity. Let's analyze it and look for better solutions. Now with google and AI allowed :D

### Algorithm complexity

This problem proposes to find a solution for the numbers of 1 - 16 but it's possible to find a list for n numbers!

Let's do a little experiment. I'll add a decorator to my function to measure the time and then I'll see how long it takes each time.

* 16 numbers: 0.02 seconds
* 25 numbers: 0.10 seconds
* 30 numbers: 1.2 seconds
* 35 numbers: 2,4 seconds
* 40 numbers: 31 seconds

This happens because the algorithm time complexity of my solution is of O(n!) (n! in the worst case)
Since my algorithm tries all cases it's trying:
- n choices
- n-1 choices
- ...
- n! choices in total

Here's the solution for 40 numbers if you're curious:
```
[1, 3, 6, 10, 39, 25, 24, 40, 9, 16, 33, 31, 18, 7, 2, 23, 26, 38, 11, 5, 20, 29, 35, 14, 22, 27, 37, 12, 13, 36, 28, 8, 17, 19, 30, 34, 15, 21, 4, 32]
```

What if I wanted to find a solution for 100 numbers? Backtracking is awesome for 16, but for 100 numbers it would take forever. Let's find another solution.
This time I'll google the solution.


## Finding the solution through the Hamiltonian path of a graph

So I googled the problem and I found this video. Turns out the guy who made the video is also the author of the book I'm reading.

<a href="https://www.youtube.com/watch?v=G1m7goLCJDY">
  <img src="/images/squaredsumvideo.png" alt="squared sum problem numberphile" style={{display: 'block', margin: '0 auto'}} />
</a>

The solution is to create a graph where each neighbour node is a possible adjacent pair. Once you place all the numbers you have to find
the path in the graph that visits every single node exactly once. To solve this I'll need an implementation of a graph in python and a function
to find the Hamiltonian path of that graph. I would also like to see the graph visually, maybe using a library.

Also, the author mentions using a hamiltonian path to solve the problem in the book, but I hadn't read that when I started this post :D

<img src="/images/pathselected.png" alt="squared sum problem numberphile" style={{display: 'block', margin: '0 auto'}} />

Building the graph is easy, but how do we find the Hamiltonian path in a way more performant than my backtracking solution?

From what I found googling, recursion is the only way but using Depth-First Search (DFS) algorithm is much better than my permutation solution.
Let's try it and see if we can find the solution for 100 numbers.

## DFS Hamiltonian path

Here's my implementation of DFS

```python
import networkx as nx
import matplotlib.pyplot as plt
import math

total_numbers = 100

squared_number_list = [number for number in range(2,total_numbers + total_numbers - 1) if math.sqrt(number) % 1 == 0]
print (squared_number_list)


def find_all_possible_neighbours(number: int) -> list[tuple]:
    possible_neighbours = [squared_number - number for squared_number in squared_number_list if \
                         squared_number - number > number and squared_number - number <= total_numbers]
    edges = [(number, neighbour) for neighbour in possible_neighbours]
    return edges

G = nx.Graph()

for number in range(1, total_numbers+1):
    G.add_node(number)
    G.add_edges_from(find_all_possible_neighbours(number))

def dfs_path_util(graph, current_node, visited, path):
    visited.add(current_node)
    path.append(current_node)

    if len(path) == total_numbers:
        return True

    for neighbor in sorted(graph.neighbors(current_node),
                           key=lambda n: sum(1 for nn in graph.neighbors(n) if nn not in visited)):
        if neighbor not in visited:
            if dfs_path_util(graph, neighbor, visited, path):
                return True

    visited.remove(current_node)
    path.pop()
    return False

def find_hamiltonian_path(graph):
    for start_node in sorted(graph.nodes(), key=lambda n: graph.degree(n)):
        visited = set()
        path = []
        if dfs_path_util(graph, start_node, visited, path):
            return path
    return None
path = find_hamiltonian_path(G)
print("Hamiltonian Path:", path)
nx.draw(G, with_labels=True, font_weight='bold')
plt.show()
```

Some notes about this implementation:
* First, we try starting with the nodes with the least amount of neighbours.
* For following nodes, we also try the ones with the least neighbours first.
* We store the visited nodes to not go through them again.
* I used networkx for the graph but I could have used an adjacency list to implement the graph.

This solution is way faster than my first solution, and the key difference is using the heuristic (kinda like a shortcut) which choses the nodes with fewest
neighbours firsts. So much faster that I can easily find the solution for 100 and 500 numbers, even if both solutions are using recursion.

And finally, here's the solution for 100 numbers:

```
[98, 71, 50, 94, 75, 46, 18, 82, 87, 57, 64, 36, 85, 84, 37, 63, 81, 88, 56, 65, 16, 33, 31, 69, 100, 44, 20, 80, 89, 32, 68, 13, 12, 52, 29, 92, 77, 67, 54, 90, 79, 42, 39, 10, 6, 58, 23, 41, 40, 60, 61, 83, 86, 35, 14, 2, 7, 93, 51, 49, 72, 9, 27, 73, 48, 96, 25, 24, 76, 5, 4, 21, 28, 8, 17, 19, 45, 55, 26, 95, 74, 47, 53, 11, 70, 30, 91, 78, 43, 38, 62, 59, 22, 3, 97, 99, 1, 15, 34, 66]
```

And here's the solution for 500 numbers

```
[450, 334, 395, 446, 338, 391, 393, 448, 336, 340, 389, 452, 332, 397, 444, 456, 328, 401, 499, 285, 291, 385, 344, 281, 248, 236, 440, 460, 324, 405, 495, 289, 387, 454, 275, 301, 228, 348, 493, 407, 377, 152, 424, 417, 483, 193, 383, 293, 436, 240, 489, 352, 432, 244, 381, 295, 330, 346, 230, 299, 485, 476, 365, 364, 312, 472, 428, 148, 477, 199, 201, 283, 342, 234, 442, 399, 277, 252, 189, 172, 269, 356, 373, 468, 261, 415, 369, 160, 164, 197, 287, 242, 434, 191, 209, 232, 497, 464, 320, 256, 185, 491, 409, 375, 466, 210, 366, 475, 486, 414, 211, 273, 403, 438, 238, 203, 326, 458, 271, 305, 224, 260, 416, 484, 357, 427, 473, 368, 208, 276, 453, 447, 129, 400, 441, 459, 117, 207, 418, 158, 371, 113, 176, 500, 461, 115, 246, 379, 350, 179, 262, 467, 494, 131, 125, 316, 413, 487, 297, 279, 250, 150, 426, 303, 181, 44, 100, 156, 205, 420, 109, 215, 226, 258, 367, 162, 322, 462, 267, 309, 220, 180, 144, 217, 183, 141, 84, 445, 396, 388, 341, 443, 133, 308, 268, 56, 140, 85, 36, 288, 496, 404, 221, 103, 66, 463, 213, 111, 465, 64, 132, 93, 76, 68, 101, 124, 45, 355, 174, 187, 254, 146, 479, 421, 363, 37, 492, 408, 121, 168, 88, 108, 376, 300, 325, 116, 28, 53, 91, 105, 471, 429, 412, 72, 457, 219, 142, 27, 229, 212, 317, 259, 65, 104, 92, 77, 119, 170, 455, 29, 20, 80, 361, 264, 265, 360, 481, 195, 430, 354, 222, 307, 177, 112, 372, 469, 315, 169, 272, 52, 173, 188, 488, 353, 223, 138, 87, 13, 311, 314, 470, 155, 329, 296, 380, 149, 107, 422, 154, 15, 274, 50, 175, 81, 63, 337, 192, 384, 57, 304, 225, 136, 60, 21, 204, 196, 480, 4, 12, 184, 216, 145, 24, 40, 41, 128, 313, 48, 96, 433, 8, 73, 123, 166, 318, 411, 165, 319, 257, 32, 17, 127, 69, 292, 437, 139, 5, 284, 392, 233, 23, 58, 86, 83, 358, 171, 25, 200, 89, 167, 157, 419, 310, 266, 359, 425, 16, 153, 43, 182, 218, 71, 253, 231, 345, 280, 9, 55, 474, 151, 249, 75, 46, 54, 235, 126, 99, 97, 159, 241, 120, 321, 255, 1, 143, 82, 402, 327, 349, 51, 49, 95, 130, 270, 406, 435, 94, 347, 137, 59, 302, 323, 161, 35, 449, 227, 134, 62, 19, 206, 370, 114, 7, 74, 70, 30, 34, 47, 482, 247, 237, 163, 33, 451, 333, 67, 14, 2, 439, 290, 194, 335, 106, 378, 351, 90, 31, 410, 374, 110, 11, 38, 251, 278, 398, 331, 245, 79, 362, 122, 239, 202, 198, 243, 118, 26, 263, 98, 386, 190, 6, 478, 306, 423, 18, 178, 498, 343, 282, 394, 135, 61, 3, 78, 22, 42, 214, 147, 294, 382, 102, 298, 431, 10, 39, 490, 186, 390, 286, 339] Woah, you made it all the way here? :D
```

## Conclusion

I had fun solving this challenge. I was able to solve it with a simple solution and then learned about
 graph theory: what Hamiltonan paths are, what is DFS, what a heuristic is, revised a little the concepts of computational complexity
 and recursion.